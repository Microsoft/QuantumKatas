% Copyright (c) Microsoft Corporation. All rights reserved.
% Licensed under the MIT License.

%!TEX program=xelatex
% This cheatsheet is based on the template
% provided at https://gist.github.com/alexander-yakushev/c773543bf9a957749f79.
\documentclass[10pt,english,landscape]{article}
\usepackage{multicol}
\usepackage{calc}
\usepackage[landscape]{geometry}
\usepackage{color,graphicx,overpic}

% https://tex.stackexchange.com/a/192067
%\usepackage{fontawesome}
 %\newfontfamily{\FA}{[FontAwesome.otf]}

% Known issue in {fontspec}: https://github.com/wspr/fontspec/issues/312#issuecomment-342125206
% Since {fontspec} is included only when compiling with XeTeX, we guard
% our fix accordingly.
\usepackage{ifxetex}
    \ifxetex
        \let\latinencoding\relax
        \usepackage{fontspec}
        %\setmainfont{Segoe UI}
        %\setmonofont{Consolas}
    \fi

% \usepackage[T1]{fontenc}
% \usepackage[bitstream-charter]{mathdesign}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{array,booktabs}
\usepackage{textcomp}
\usepackage[usenames,dvipsnames,table]{xcolor}
\usepackage[most]{tcolorbox}
\usepackage{menukeys}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{tikz}
\usepackage{environ}
\usepackage{braket}

\usetikzlibrary{calc}
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

\geometry{top=-0.1cm,left=0.3cm,right=0.3cm,bottom=0.3cm}

\pagestyle{empty} % Turn off header and footer

% \renewcommand\rmdefault{phv} % Arial
% \renewcommand\sfdefault{phv} % Arial

% Redefine section commands to use less space
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
  {-1ex plus -.5ex minus -.2ex}%
  {0.5ex plus .2ex}%x
  {\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
  {-1explus -.5ex minus -.2ex}%
  {0.5ex plus .2ex}%
  {\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
  {-1ex plus -.5ex minus -.2ex}%
  {1ex plus .2ex}%
  {\normalfont\small\bfseries}}
\makeatother

\setcounter{secnumdepth}{0} % Don't print section numbers
\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}

\definecolor{TableHead}{rgb}{0.353, 0.329, 0.667}
\definecolor{TableRow}{rgb}{0.816, 0.812, 0.902}

\NewEnviron{keysref}[1]{
  % \begin{center}
  \smallskip
  \begin{tikzpicture}
      \rowcolors{1}{}{TableRow}

      \node (tbl) [inner sep=0pt] {
        \begin{tabular}{p{2.5cm}p{5.05cm}}
          \rowcolor{TableHead}
          \multicolumn{2}{l}{\normalsize\textbf{\color{white}{#1}}}\parbox{0pt}{\rule{0pt}{0.3ex+\baselineskip}}\\
          \BODY
          \arrayrulecolor{TableHead}\specialrule{.17em}{0em}{.2em}
        \end{tabular}};
      \begin{pgfonlayer}{background}
        \draw[rounded corners=2pt,top color=TableHead,bottom color=TableHead, draw=white]
        ($(tbl.north west)-(0,-0.05)$) rectangle ($(tbl.north east)-(0.0,0.15)$);
        \draw[rounded corners=2pt,top color=TableHead,bottom color=TableHead, draw=white]
        ($(tbl.south west)-(0.0,-0.11)$) rectangle ($(tbl.south east)-(-0.0,-0.02)$);
      \end{pgfonlayer}
    \end{tikzpicture}
  % \end{center}
}

% https://tex.stackexchange.com/a/102523
\newcommand{\forceindent}[1]{\leavevmode{\parindent=#1\indent}}

%% CUSTOM NOTATION %%

\newcommand{\qs}{Q\#}
\newcommand{\unixlike}{\hfill\faApple\faLinux}
\newcommand{\ctrllike}{\hfill\faWindows\faLinux}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\raggedright\

% \begin{center}
  \Large{\qs~0.10 Language Quick Reference}
% \end{center}

\footnotesize
\begin{multicols}{3}

  \begin{keysref}{Primitive Types}
    64-bit integers         & \texttt{Int} \\
    Double-precision floats & \texttt{Double} \\
    Booleans                & \texttt{Bool}   \newline 
                              e.g.: \texttt{true} or \texttt{false} \\
    Qubits                  & \texttt{Qubit}  \\
    Pauli basis             & \texttt{Pauli}  \newline
                              e.g.: \texttt{PauliI}, \texttt{PauliX}, \texttt{PauliY}, or \texttt{PauliZ} \\
    Measurement \newline results     & \texttt{Result} \newline
                              e.g.: \texttt{Zero} or \texttt{One} \\
    Sequences of \newline integers   & \texttt{Range}  \newline
                              e.g.: 1..10 or 5..-1..0 \\
    Strings                 & \texttt{String} \\
    "Return no \newline information" type   & \texttt{Unit} \newline e.g.: \texttt{()} \\
  \end{keysref}

  \begin{keysref}{Derived Types}
    Arrays                  & \texttt{\emph{elementType}[]} \\
    Tuples                  & \texttt{(\emph{type0}, \emph{type1}, ...)} \newline
                              e.g.: \texttt{(Int, Qubit)} \\
    Functions               & \texttt{\emph{input} -> \emph{output}} \newline
                              e.g.: \texttt{ArcCos : (Double) -> Double} \\
     Operations               & \texttt{\emph{input} => \emph{output} \emph{variants}} \newline
                              e.g.: \texttt{H : (Qubit => Unit : \newline Adj + Ctl)} \\
  \end{keysref}
  
  \begin{keysref}{User-Defined Types}
  Declare UDT with anonymous items & \texttt{UDTName \emph{Name} = (Type, Type);} \newline
            e.g.:\texttt{ newtype \emph{Complex} = (Double, Double);} \\
  Declare UDT with named items &  \texttt{newtype \emph{Name} = (\emph{Name1}: Type, \emph{Name2}: Type);} \newline
  e.g.: \texttt{newtype Complex = (Re : Double, Im : Double);} \\
  Advantage of named items & \texttt{Access directly via the access operator ::} \newline
 e.g.: \texttt{function Addition (c1 : Complex, c2 : Complex) : Complex {
    return Complex(c1::Re + c2::Re, c1::Im + c2::Im);}
} \\
  nested UDT & \texttt{newtype \emph{UDTName} = (type, (\emph{Name2} : type, type)); } \newline
            e.g.: \texttt{\emph{newtype}  Nested = (Double, (ItemName : Int, String));} \\
 Unwrap operator ! & \texttt{Used for unnamed newtypes} \\
 Unwrap operator usage & \texttt{newtype WrapInt = Int;} \newline
\texttt{newtype TwoWrapInt = WrapInt;} \newline
    \texttt{let x = TwoWrapInt(WrapInt(6));} \newline
    \texttt{let y = x!;} \newline \texttt{y is WrapInt(6).} \newline
    \texttt{let z = x!!;} \newline \texttt{z is 6.} \newline
    \texttt{let c = x!! + 5;} \newline \texttt{c is 11.} \\Update-and-reassign & \textt{newtype Complex = (Re : Double);} \newline
\texttt{function \emph{AddAll} (\emph{reals} : Double[])} : \texttt{Complex[]} {\}} \newline 
    \texttt{mutable \emph{res} = Complex(0.);} \newline
    \texttt{for (\emph{r} in \emph{reals})  \{ } \newline
        \texttt{set \emph{res} w/= \emph{Re} <- \emph{res}::\emph{Re} + \emph{r}; // update-and-reassign statement} \newline
   {\}} \newline
    \texttt{return res;} \newline
{\}}  \\
  \end{keysref}
  

  \begin{keysref}{Functions and Operations}
    Define function \newline (classical routine)
              & \texttt{function \emph{Name}(\emph{in0} : \emph{type0}, ...) : \emph{returnType} \{} \newline
                \texttt{\hphantom{....}// \emph{function body}} \newline
                \texttt{\}} \\
    Define operation \newline (quantum routine)
               & \texttt{operation \emph{Name}(\emph{in0} : \emph{type0}, ...) : \emph{returnType} \{} \newline
                 \texttt{\hphantom{....}body \{ ... \}} \newline
                 \texttt{\hphantom{....}adjoint \{ ... \}} \newline
                 \texttt{\hphantom{....}controlled \{ ... \}} \newline
                 \texttt{\hphantom{....}adjoint controlled \{ ... \}} \newline
                 \texttt{\}} \\
    Call adjoint \newline operation & \texttt{Adjoint \emph{Name}(\emph{parameters})} \\
    Call controlled \newline operation & \texttt{Controlled \emph{Name}(\emph{controlQubits}, \emph{parameters})} \\
    Call automatically adjoint and controlled operation & \texttt{operation \emph{PrepareEntangledPair}(\emph{here}: Qubit, \emph{there} : Qubit) : Unit is Adj+Ctl} \newline
                                                                                              \texttt{\hphantom{....}body \{ ... \}} \\
  \end{keysref}
  \begin{keysref}{Symbols and Variables}
    Declare immutable \newline symbol & \texttt{let \emph{name} = \emph{value}} \\
    Declare mutable \newline symbol (variable)  & \texttt{mutable \emph{name} = \emph{initialValue}} \\
    Update mutable \newline symbol (variable)   & \texttt{set \emph{name} = \emph{newValue}} \\
    Apply-and-Reassign & \texttt{set \emph{name}  \emph{operator} = \emph{expression}} \newline
    e.g.: \texttt{mutable \emph{counter} = \emph{0};} \newline
    \texttt{ set counter += \emph{someValue};} \\ 
  \end{keysref}

  \begin{keysref}{Arrays}
    Allocation           & \texttt{mutable \emph{name} = new \emph{Type}[\emph{length}]} \\
    Length               & \texttt{Length(\emph{name})} \\
    k-th element         & \texttt{\emph{name}[k]} \newline NB: indices are 0-based  \\
    Array literal        & \texttt{[\emph{value0}, \emph{value1}, ...]} \newline
                           e.g.: \texttt{[true, false, true]} \\
    Slicing (subarray)   & \texttt{\emph{name}[\emph{start}...\emph{end}]} \\
    
    \texttt{\emph{name}[\emph{start}...]} &
    \texttt{let arr = [1,2,3,4,5,6];} \newline
    \texttt{let slice1  = arr[3...];} \newline \texttt{slice1 is [4,5,6];} \\
    \texttt{\emph{name}[...\emph{end}]} & \texttt{let arr = [1,2,3,4,5,6];} \newline
    \texttt{let slice3  = arr[...2];} \newline \texttt{slice3 is [1,2,3];} \\
    \texttt{\emph{name}[...index...]} & \texttt{let arr = [1,2,3,4,5,6];} \newline 
    \texttt{let slice5  = arr[...2...];} \newline \texttt{slice5 is [1,3,5];} \\
    \texttt{\emph{name}[...-index...]} & \texttt{let arr = [1,2,3,4,5,6];} \newline 
    \texttt{let slice9  = arr[...-1...];} \newline \texttt{slice9 is [6,5,4,3,2,1];}  \\    								
  \end{keysref}

  \begin{keysref}{Control Flow}
    For loop           & \texttt{for (\emph{index} in \emph{range}) \{ }\newline 
                         \texttt{\hphantom{....}//} Use integer \texttt{\emph{index}} \newline
                         \texttt{\}} \newline
                         e.g.: \texttt{for (i in 0..N-1) \{ ... \}} \\
    While loop  & \texttt{while ( ... )} \newline
    						\texttt{{...}} \\
    Iterate over \newline an array & \texttt{for (\emph{val} in \emph{array}) \{ }\newline 
                                     \texttt{\hphantom{....}//} Use value \texttt{\emph{val}} \newline
                                     \texttt{\}} \newline
                                     e.g.: \texttt{for (q in register) \{ ... \}} \\                                
    Repeat-until-success loop  & \texttt{repeat \{ ... \} \newline until (\emph{condition}) \newline fixup \{ ... \}} \\
    Conditional \newline statement      & \texttt{if (\emph{cond1}) \{ ... \} \newline elif (\emph{cond2}) \{ ... \} \newline else \{ ... \}}\\
    Ternary operator   & \texttt{\emph{condition} ? \emph{caseTrue} | \emph{caseFalse} } \\
    Return a value     & \texttt{return \emph{value}} \\
    Stop with an error & \texttt{fail "\emph{Error message}"}\\
  \end{keysref}
   
   \begin{keysref}{Conjugations}
	Apply ... Within & \texttt{operation \emph{Name}(\emph{in0} : \emph{type0}, ...) : \emph{returnType} \{} \newline
                 \texttt{\hphantom{....}within \{ ... \}} \newline
                 \texttt{\hphantom{....}apply \{ ... \}} \newline
                 \texttt{\}} \newline 
                 i.e. \texttt{withinBlock - applyBlock - Adjoint withinBlock sequence} \\
   \end{keysref}
  
  \begin{keysref}{Debugging}
    Print a string     & \texttt{Message("Hello Quantum!")} \\
    Print an \newline interpolated string   
                       & \texttt{Message(\$"Value = \{\emph{val}\}")} \\
    Assert that a qubit is in $\ket{0}$ or $\ket{1}$ state   & \texttt{AssertQubit(Zero, \emph{oneQubit})}\\
    Print amplitudes \newline of wave function & \texttt{DumpMachine("dump.txt")} \\
  \end{keysref}
  
  \begin{keysref}{Qubit Allocation}
    Allocate qubits      & \texttt{using (\emph{reg} = Qubit[\emph{length}]) \{} \newline
                           \texttt{\hphantom{....}//} Qubits in \texttt{\emph{reg}} start in $\ket{0}$. \newline
                           \texttt{\hphantom{....}...} \newline
                           \texttt{\hphantom{....}//} Qubits must be returned to $\ket{0}$. \newline
                           \texttt{\}} \\
    Allocate one qubit   & \texttt{using (\emph{one} = Qubit()) \{ ... \} } \\
    Allocate multiple qubits & \texttt{using (\emph{x}, \emph{y}, .... )} = \texttt{(Qubit[N], Qubit(), ... )}, \newline
                                                 \texttt{where N is a arbitrary number of qubits} \\
  \end{keysref}
  \begin{keysref}{Measurements}
    Measure qubit in Pauli $Z$ basis & \texttt{M(\emph{oneQubit})} \newline yields a \texttt{Result} (\texttt{Zero} or \texttt{One}) \\
    Reset qubit to $\ket{0}$     & \texttt{Reset(\emph{oneQubit})} \\
    Reset an array of \newline qubits to $\ket{0..0}$ & \texttt{ResetAll(\emph{register})} \\
  \end{keysref}

  \begin{keysref}{Basic Gates}
    Pauli gates          & \texttt{X(\emph{qubit})} : \newline
                           $\ket{0} \mapsto \ket{1}$, $\ket{1} \mapsto \ket{0}$ \newline
                           \texttt{Y(\emph{qubit})} : \newline
                           $\ket{0} \mapsto i \ket{1}$, $\ket{1} \mapsto -i \ket{0}$ \newline
                           \texttt{Z(\emph{qubit})} : \newline
                           $\ket{0} \mapsto \ket{0}$, $\ket{1} \mapsto -\ket{1}$ \\
    Hadamard             & \texttt{H(\emph{qubit})} : \newline
                           $\ket{0} \mapsto \ket{+} = \frac{1}{\sqrt{2}} ( \ket{0} + \ket{1} )$, \newline
                           $\ket{1} \mapsto \ket{-} = \frac{1}{\sqrt{2}} ( \ket{0} - \ket{1} )$ \\
    Controlled-NOT       & \texttt{CNOT(\emph{controlQubit}, \emph{targetQubit})} \newline
                           $\ket{00} \mapsto \ket{00}$, $\ket{01} \mapsto \ket{01}$, \newline
                           $\ket{10} \mapsto \ket{11}$, $\ket{11} \mapsto \ket{10}$ \\
    Apply several gates \newline (Bell pair example)  & \texttt{H(\emph{qubit1});} \newline 
                                                        \texttt{CNOT(\emph{qubit1}, \emph{qubit2});} \\
  \end{keysref}
 
  \section{Resources}
  
  \begin{keysref}{Documentation}
    Quantum \newline Development Kit & \url{https://docs.microsoft.com/quantum} \\
    \qs~Language \newline Reference & \url{https://docs.microsoft.com/quantum/language/} \\
    \qs~Library \newline Reference  & \url{https://docs.microsoft.com/qsharp/api} \\
  \end{keysref}

  \begin{keysref}{\qs~Code Repositories}
    QDK Samples               & \url{https://github.com/Microsoft/Quantum} \\
    QDK Libraries             & \url{https://github.com/Microsoft/QuantumLibraries} \\
    Quantum Katas \newline (tutorials) & \url{https://github.com/Microsoft/QuantumKatas} \\
  \end{keysref}

  \begin{keysref}{Command Line Basics}
    Change directory    & \texttt{cd \emph{dirname}} \\
    Go to home          & \texttt{cd \textasciitilde} \\
    Go up one directory & \texttt{cd ..} \\
    Make new directory  & \texttt{mkdir \emph{dirname}} \\
    Open current \newline directory in VS Code & \texttt{code .} \\
  \end{keysref}

  \begin{keysref}{Working with \qs~Projects}
    Create new project & \texttt{dotnet new console -lang Q\# --output \emph{project-dir}} \\
    Change directory to \newline project directory & \texttt{cd \emph{project-dir}} \\
    Build project                     & \texttt{dotnet build} \\
    Run all unit tests                & \texttt{dotnet test} \\
  \end{keysref}

 \end{multicols}

\end{document} 
